# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/typeprof/all/typeprof.rbi
#
# typeprof-0.21.11

module TypeProf
  def self.analyze(config, cancel_token = nil); end
  def self.start_lsp_server(config); end
  def self.starting_state(iseq); end
end
class TypeProf::ConfigData < Struct
  def check_dir_filter(path); end
  def collection_path; end
  def collection_path=(_); end
  def dir_filter; end
  def dir_filter=(_); end
  def gem_rbs_features; end
  def gem_rbs_features=(_); end
  def initialize(**opt); end
  def lsp; end
  def lsp=(_); end
  def lsp_options; end
  def lsp_options=(_); end
  def max_iter; end
  def max_iter=(_); end
  def max_sec; end
  def max_sec=(_); end
  def options; end
  def options=(_); end
  def output; end
  def output=(_); end
  def rb_files; end
  def rb_files=(_); end
  def rbs_files; end
  def rbs_files=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def verbose; end
  def verbose=(_); end
end
class TypeProf::TypeProfError < StandardError
  def report(output); end
end
module TypeProf::Config
  def self.current; end
  def self.set_current(config); end
end
module TypeProf::Utils
  def self.array_update(ary, idx, elem); end
end
module TypeProf::Utils::StructuralEquality
  def self.included(klass); end
end
class TypeProf::Utils::Set
  def add(new_val); end
  def each(&blk); end
  def include?(elem); end
  def initialize(tbl); end
  def inspect; end
  def intersection(other); end
  def map(&blk); end
  def self.[](*values); end
  def self.new(*args); end
  def size; end
  def sum(other); end
  def tbl; end
  include Enumerable
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::Utils::MutableSet
  def <<(v); end
  def [](v); end
  def delete(v); end
  def each(&blk); end
  def initialize(*values); end
  def inspect; end
  def size; end
  def to_set; end
  include Enumerable
end
class TypeProf::Utils::HashWrapper
  def initialize(hash); end
  def internal_hash; end
  def self.new(*args); end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::Utils::WorkList
  def deletemin; end
  def empty?; end
  def initialize; end
  def insert(key, val); end
  def inspect; end
  def member?(val); end
  def size; end
end
class TypeProf::Utils::CancelToken
  def cancelled?; end
end
class TypeProf::Utils::TimerCancelToken < TypeProf::Utils::CancelToken
  def cancelled?; end
  def initialize(max_sec); end
end
class TypeProf::Type
  def each_child; end
  def each_child_global; end
  def each_free_type_variable; end
  def generate_substitution; end
  def globalize(_env, _visited, _depth); end
  def include_untyped?(_scratch); end
  def initialize; end
  def limit_size(limit); end
  def localize(env, _alloc_site, _depth); end
  def remove_type_vars; end
  def self.any; end
  def self.bool; end
  def self.bot; end
  def self.builtin_global_variable_type(var); end
  def self.gen_hash(base_ty = nil); end
  def self.guess_literal_type(obj); end
  def self.match?(ty1, ty2); end
  def self.merge_substitution(subst1, subst2); end
  def self.new(*args); end
  def self.nil; end
  def self.optional(ty); end
  def substitute(_subst, _depth); end
  def union(other); end
  def union_elems(e1, e2); end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::Type::Any < TypeProf::Type
  def consistent?(_other); end
  def include_untyped?(_scratch); end
  def initialize; end
  def inspect; end
  def method_dispatch_info; end
  def screen_name(scratch); end
  def substitute(_subst, _depth); end
end
class TypeProf::Type::Void < TypeProf::Type::Any
  def inspect; end
  def screen_name(scratch); end
end
class TypeProf::Type::Union < TypeProf::Type
  def consistent?(_other); end
  def each_child(&blk); end
  def each_child_global(&blk); end
  def each_free_type_variable(&blk); end
  def elems; end
  def globalize(env, visited, depth); end
  def include_untyped?(scratch); end
  def initialize(tys, elems); end
  def inspect; end
  def limit_size(limit); end
  def localize(env, alloc_site, depth); end
  def screen_name(scratch); end
  def self.create(tys, elems); end
  def substitute(subst, depth); end
  def types; end
end
class TypeProf::Type::Var < TypeProf::Type
  def add_subst!(ty, subst); end
  def consistent?(_other); end
  def each_free_type_variable; end
  def initialize(name); end
  def screen_name(scratch); end
  def substitute(subst, depth); end
end
class TypeProf::Type::Class < TypeProf::Type
  def consistent?(other); end
  def idx; end
  def initialize(kind, idx, type_params, superclass, name); end
  def inspect; end
  def kind; end
  def method_dispatch_info; end
  def screen_name(scratch); end
  def substitute(_subst, _depth); end
  def superclass; end
  def superclass_type_args; end
  def superclass_type_args=(arg0); end
  def type_params; end
end
class TypeProf::Type::Instance < TypeProf::Type
  def consistent?(other); end
  def include_subclasses; end
  def initialize(klass, include_subclasses = nil); end
  def inspect; end
  def klass; end
  def method_dispatch_info; end
  def screen_name(scratch); end
  def self.new_degenerate(instances); end
  def substitute(subst, depth); end
end
class TypeProf::Type::ISeq < TypeProf::Type
  def initialize(iseq); end
  def inspect; end
  def iseq; end
  def screen_name(_scratch); end
end
class TypeProf::Type::Proc < TypeProf::Type
  def base_type; end
  def block_body; end
  def consistent?(other); end
  def include_untyped?(scratch); end
  def initialize(block_body, base_type); end
  def method_dispatch_info; end
  def screen_name(scratch); end
  def substitute(subst, depth); end
end
class TypeProf::Type::Symbol < TypeProf::Type
  def base_type; end
  def consistent?(other); end
  def initialize(sym, base_type); end
  def inspect; end
  def method_dispatch_info; end
  def screen_name(scratch); end
  def substitute(_subst, _depth); end
  def sym; end
end
class TypeProf::Type::Literal < TypeProf::Type
  def base_type; end
  def consistent?(_other); end
  def globalize(_env, _visited, _depth); end
  def initialize(lit, base_type); end
  def inspect; end
  def lit; end
  def method_dispatch_info; end
  def screen_name(scratch); end
end
class TypeProf::Type::HashGenerator
  def []=(k_ty, v_ty); end
  def initialize; end
  def map_tys; end
end
class TypeProf::Signature
  def screen_name(iseq, scratch); end
  def self.new(*args); end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::MethodSignature < TypeProf::Signature
  def blk_ty; end
  def include_untyped?(scratch); end
  def initialize(lead_tys, opt_tys, rest_ty, post_tys, kw_tys, kw_rest_ty, blk_ty); end
  def kw_rest_ty; end
  def kw_tys; end
  def lead_tys; end
  def merge(other); end
  def merge_as_block_arguments(other); end
  def opt_tys; end
  def post_tys; end
  def rest_ty; end
  def substitute(subst, depth); end
end
class TypeProf::BlockSignature < TypeProf::Signature
  def blk_ty; end
  def initialize(lead_tys, opt_tys, rest_ty, blk_ty); end
  def lead_tys; end
  def merge(bsig); end
  def opt_tys; end
  def rest_ty; end
end
class TypeProf::AllocationSite
  def add_id(val); end
  def initialize(val, parent = nil); end
  def parent; end
  def self.new(*args); end
  def val; end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::Type::ContainerType < TypeProf::Type
  def consistent?(other); end
  def each_free_type_variable(&blk); end
  def include_untyped?(scratch); end
  def match?(other); end
  def self.create_empty_instance(klass); end
end
class TypeProf::Type::Cell < TypeProf::Type::ContainerType
  def base_type; end
  def elems; end
  def generate_substitution; end
  def initialize(elems, base_type); end
  def inspect; end
  def limit_size(limit); end
  def localize(env, alloc_site, depth); end
  def method_dispatch_info; end
  def screen_name(scratch); end
  def substitute(subst, depth); end
end
class TypeProf::Type::Cell::Elements
  def [](idx); end
  def each_free_type_variable(&blk); end
  def elems; end
  def globalize(env, visited, depth); end
  def include_untyped?(scratch); end
  def initialize(elems); end
  def limit_size(limit); end
  def localize(env, alloc_site, depth); end
  def match?(other); end
  def pretty_print(q); end
  def screen_name(scratch); end
  def self.dummy_elements; end
  def self.new(*args); end
  def substitute(subst, depth); end
  def to_local_type(id, base_ty); end
  def union(other); end
  def update(idx, ty); end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::Type::Array < TypeProf::Type::ContainerType
  def base_type; end
  def elems; end
  def generate_substitution; end
  def initialize(elems, base_type); end
  def inspect; end
  def limit_size(limit); end
  def localize(env, alloc_site, depth); end
  def method_dispatch_info; end
  def screen_name(scratch); end
  def substitute(subst, depth); end
end
class TypeProf::Type::Array::Elements
  def [](idx); end
  def append(ty); end
  def each_free_type_variable(&blk); end
  def globalize(env, visited, depth); end
  def include_untyped?(scratch); end
  def initialize(lead_tys, rest_ty = nil); end
  def lead_tys; end
  def limit_size(limit); end
  def localize(env, alloc_site, depth); end
  def match?(other); end
  def pretty_print(q); end
  def rest_ty; end
  def screen_name(scratch); end
  def self.dummy_elements; end
  def self.new(*args); end
  def squash; end
  def squash_or_any; end
  def substitute(subst, depth); end
  def take_first(num); end
  def take_last(num); end
  def to_local_type(id, base_ty); end
  def union(other); end
  def update(idx, ty); end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::Type::Hash < TypeProf::Type::ContainerType
  def base_type; end
  def elems; end
  def generate_substitution; end
  def initialize(elems, base_type); end
  def inspect; end
  def limit_size(limit); end
  def localize(env, alloc_site, depth); end
  def method_dispatch_info; end
  def screen_name(scratch); end
  def substitute(subst, depth); end
end
class TypeProf::Type::Hash::Elements
  def [](key_ty); end
  def each_free_type_variable(&blk); end
  def globalize(env, visited, depth); end
  def include_untyped?(scratch); end
  def initialize(map_tys); end
  def limit_size(limit); end
  def localize(env, alloc_site, depth); end
  def map_tys; end
  def match?(other); end
  def pretty_print(q); end
  def screen_name(scratch); end
  def self.dummy_elements; end
  def self.new(*args); end
  def squash; end
  def substitute(subst, depth); end
  def to_keywords; end
  def to_local_type(id, base_ty); end
  def union(other); end
  def update(idx, ty); end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::Type::Local < TypeProf::Type::ContainerType
  def base_type; end
  def globalize(env, visited, depth); end
  def id; end
  def initialize(kind, id, base_type); end
  def inspect; end
  def kind; end
  def method_dispatch_info; end
  def screen_name(scratch); end
  def update_container_elem_type(subst, env, caller_ep, scratch); end
end
class TypeProf::MethodDef
  def pub_meth; end
  def pub_meth=(arg0); end
  def self.new(*args); end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::ISeqMethodDef < TypeProf::MethodDef
  def do_check_send(msig, recv, mid, ep, scratch); end
  def do_send(recv, mid, aargs, caller_ep, caller_env, scratch, &ctn); end
  def initialize(iseq, cref, outer_ep, pub_meth); end
  def iseq; end
end
class TypeProf::AliasMethodDef < TypeProf::MethodDef
  def def_ep; end
  def do_check_send(msig, recv, mid, ep, scratch); end
  def do_send(recv, _mid, aargs, caller_ep, caller_env, scratch, &ctn); end
  def initialize(orig_mid, mdef, def_ep); end
  def mdef; end
  def orig_mid; end
end
class TypeProf::AttrMethodDef < TypeProf::MethodDef
  def do_send(recv, mid, aargs, caller_ep, caller_env, scratch, &ctn); end
  def initialize(ivar, kind, pub_meth); end
  def ivar; end
  def kind; end
end
class TypeProf::ExecutedAttrMethodDef < TypeProf::AttrMethodDef
  def def_ep; end
  def initialize(ivar, kind, pub_meth, def_ep); end
end
class TypeProf::TypedAttrMethodDef < TypeProf::AttrMethodDef
  def initialize(ivar, kind, pub_meth, rbs_source); end
  def rbs_source; end
end
class TypeProf::TypedMethodDef < TypeProf::MethodDef
  def do_match_iseq_mdef(iseq_mdef, recv, mid, env, ep, scratch); end
  def do_send(recv_orig, mid, aargs, caller_ep, caller_env, scratch, &ctn); end
  def initialize(sig_rets, rbs_source, pub_meth); end
  def iseq; end
  def rbs_source; end
end
class TypeProf::CustomMethodDef < TypeProf::MethodDef
  def do_send(recv, mid, aargs, caller_ep, caller_env, scratch, &ctn); end
  def initialize(impl, pub_meth); end
end
class TypeProf::Block
  def self.new(*args); end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::ISeqBlock < TypeProf::Block
  def consistent?(other); end
  def do_call(aargs, caller_ep, caller_env, scratch, replace_recv_ty:, replace_cref:, &ctn); end
  def initialize(iseq, ep); end
  def inspect; end
  def iseq; end
  def outer_ep; end
  def substitute(_subst, _depth); end
end
class TypeProf::TypedBlock < TypeProf::Block
  def consistent?(other); end
  def do_call(aargs, caller_ep, caller_env, scratch, replace_recv_ty:, replace_cref:, &ctn); end
  def initialize(msig, ret_ty); end
  def msig; end
  def ret_ty; end
  def substitute(subst, depth); end
end
class TypeProf::SymbolBlock < TypeProf::Block
  def consistent?(other); end
  def do_call(aargs, caller_ep, caller_env, scratch, replace_recv_ty:, replace_cref:, &ctn); end
  def initialize(sym); end
  def inspect; end
  def iseq; end
  def outer_ep; end
  def substitute(_subst, _depth); end
end
class TypeProf::CustomBlock < TypeProf::Block
  def consistent?(other); end
  def do_call(aargs, caller_ep, caller_env, scratch, replace_recv_ty:, replace_cref:, &ctn); end
  def initialize(caller_ep, mid, &blk); end
  def inspect; end
  def substitute(_subst, _depth); end
end
class TypeProf::ISeq
  def <=>(other); end
  def absolute_path; end
  def add_body_start_marker(insns); end
  def add_called_iseq(pc, callee_iseq); end
  def add_def_loc(pc, detailed_loc); end
  def add_exception_cont_marker(insns, catch_table); end
  def callers; end
  def catch_table; end
  def check_send_branch(sp, j); end
  def collect_local_variable_info(file_info, absolute_level = nil, parent_variable_tables = nil); end
  def convert_insns(insns, node_ids, file_info); end
  def create_label_table(insns); end
  def detailed_source_location(pc); end
  def extract_method_name_token_range(node); end
  def fargs_format; end
  def id; end
  def initialize(iseq, file_info); end
  def insns; end
  def iseq_code_range; end
  def locals; end
  def name; end
  def path; end
  def pretty_print(q); end
  def rename_insn_types; end
  def self.build_ast_node_id_table(node, tbl = nil); end
  def self.code_range_from_node(node); end
  def self.compile(file); end
  def self.compile_core(str, path); end
  def self.compile_str(str, path = nil); end
  def self.find_node_by_id(node, id); end
  def setup_insns(insns, labels, file_info); end
  def should_collect_defs(insn_kind); end
  def source_location(pc); end
  def start_lineno; end
  def type; end
  def unify_instructions; end
end
class TypeProf::ISeq::FileInfo < Struct
  def caller_table; end
  def caller_table=(_); end
  def created_iseqs; end
  def created_iseqs=(_); end
  def definition_table; end
  def definition_table=(_); end
  def node_id2node; end
  def node_id2node=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class TypeProf::ISeq::Insn < Struct
  def check?(insn_cmp, operands_cmp = nil); end
  def code_range; end
  def code_range=(_); end
  def definitions; end
  def definitions=(_); end
  def insn; end
  def insn=(_); end
  def lineno; end
  def lineno=(_); end
  def operands; end
  def operands=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class TypeProf::ActualArguments
  def argument_error(given, exp_lower, exp_upper); end
  def blk_ty; end
  def consistent_with_method_signature?(msig); end
  def for_method_missing(mid); end
  def globalize(caller_env, visited, depth); end
  def initialize(lead_tys, rest_ty, kw_tys, blk_ty); end
  def kw_tys; end
  def lead_tys; end
  def limit_size(limit); end
  def node_id; end
  def node_id=(arg0); end
  def rest_ty; end
  def setup_formal_arguments(kind, locals, fargs_format); end
  def to_block_signature; end
end
class TypeProf::CRef
  def extend(klass, singleton); end
  def initialize(outer, klass, singleton); end
  def klass; end
  def outer; end
  def pretty_print(q); end
  def self.new(*args); end
  def singleton; end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::Context
  def cref; end
  def detailed_source_location(pc); end
  def initialize(iseq, cref, mid); end
  def iseq; end
  def mid; end
  def replace_cref(cref); end
  def self.new(*args); end
  def source_location(pc); end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::TypedContext
  def caller_ep; end
  def detailed_source_location(_pc); end
  def initialize(caller_ep, mid); end
  def mid; end
  def replace_cref(cref); end
  def self.new(*args); end
  def source_location(_pc); end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::ExecutionPoint
  def absolute_path; end
  def ctx; end
  def detailed_source_location; end
  def initialize(ctx, pc, outer); end
  def jump(pc); end
  def key; end
  def next; end
  def outer; end
  def pc; end
  def replace_cref(cref); end
  def self.new(*args); end
  def source_location; end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::StaticEnv
  def blk_ty; end
  def initialize(recv_ty, blk_ty, mod_func, pub_meth); end
  def merge(other); end
  def mod_func; end
  def pub_meth; end
  def recv_ty; end
  def self.new(*args); end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::Env
  def deploy_type(id, elems); end
  def enable_module_function; end
  def get_container_elem_types(id); end
  def get_local(idx); end
  def initialize(static_env, locals, stack, type_params); end
  def inspect; end
  def local_update(idx, ty); end
  def locals; end
  def merge(other); end
  def method_public_set(flag); end
  def pop(n); end
  def push(*tys); end
  def replace_blk_ty(ty); end
  def replace_recv_ty(ty); end
  def self.new(*args); end
  def setn(i, ty); end
  def stack; end
  def static_env; end
  def topn(i); end
  def type_params; end
  include TypeProf::Utils::StructuralEquality
end
class TypeProf::Scratch
  def add_attr_method(klass, mid, ivar, kind, pub_meth, ep); end
  def add_block_signature!(block_body, bsig); end
  def add_block_to_ctx!(block_body, ctx); end
  def add_callsite!(callee_ctx, caller_ep, caller_env, &ctn); end
  def add_constant(klass, name, value, def_ep); end
  def add_cvar_read!(klass, var, ep, &ctn); end
  def add_cvar_write!(klass, var, ty, ep); end
  def add_edge(ep, next_ep); end
  def add_entrypoint(iseq); end
  def add_executed_iseq(iseq); end
  def add_gvar_read!(var, ep, &ctn); end
  def add_gvar_write!(var, ty, ep); end
  def add_iseq_method(klass, mid, iseq, cref, outer_ep, pub_meth); end
  def add_iseq_method_call!(iseq_mdef, ctx); end
  def add_ivar_read!(recv, var, ep, &ctn); end
  def add_ivar_write!(recv, var, ty, ep); end
  def add_method(klass, mid, singleton, mdef); end
  def add_method_signature!(callee_ctx, msig); end
  def add_return_value!(callee_ctx, ret_ty); end
  def add_singleton_iseq_method(klass, mid, iseq, cref, outer_ep, pub_meth); end
  def add_superclass_type_args!(klass, tyargs); end
  def add_typed_attr_method(klass, mdef); end
  def adjust_substitution(klass, singleton, mid, mthd, subst, &blk); end
  def alias_method(klass, singleton, alias_mid, orig_mid, ep); end
  def cbase_path(cbase); end
  def check_typed_attr(klass, mid, singleton); end
  def check_typed_method(klass, mid, singleton); end
  def class_defs; end
  def do_define_iseq_method(ep, env, mid, iseq, outer_ep); end
  def do_expand_array(ep, env, elems, num, splat, from_head); end
  def do_invoke_block(blk, aargs, ep, env, replace_recv_ty: nil, replace_cref: nil, &ctn); end
  def do_send(recvs, mid, aargs, ep, env, &ctn); end
  def error(ep, msg); end
  def get_all_methods(klass, singleton, _include_subclasses); end
  def get_all_super_methods(klass, singleton, current_klass, mid); end
  def get_array_elem_type(env, ep, id, idx = nil); end
  def get_class_name(klass); end
  def get_constant(klass, name); end
  def get_container_elem_types(env, ep, id); end
  def get_env(ep); end
  def get_hash_elem_type(env, ep, id, key_ty = nil); end
  def get_instance_variable(recv, var, ep, env); end
  def get_ivar(recv, var); end
  def get_method(klass, singleton, include_subclasses, mid); end
  def get_super_method(ctx, singleton); end
  def globalize_type(ty, env, ep); end
  def identify_class_for_ivar(recv, var); end
  def initialize; end
  def inspect; end
  def loaded_files; end
  def localize_type(ty, env, ep, alloc_site = nil); end
  def merge_env(ep, env); end
  def merge_return_env(caller_ep); end
  def mix_module(kind, mixing_mod, mixed_mod, type_args, singleton, caller_ep); end
  def namespace; end
  def namespace=(arg0); end
  def new_class(cbase, name, type_params, superclass, def_ep); end
  def new_struct(ep); end
  def pend_block_dummy_execution(blk, iseq, nep, nenv); end
  def pend_method_execution(iseq, meth, recv, mid, cref, ep); end
  def rbs_reader; end
  def report(stat_eps, output); end
  def report_lsp; end
  def return_envs; end
  def reveal_type(ep, ty); end
  def ruby_3_3_keywords?; end
  def search_constant(cref, name); end
  def search_method(klass, singleton, mid, &blk); end
  def set_custom_method(klass, mid, impl, pub_meth = nil); end
  def set_instance_variable(recv, var, ty, ep, env); end
  def set_method(klass, mid, singleton, mdef); end
  def set_singleton_custom_method(klass, mid, impl, pub_meth = nil); end
  def setup_actual_arguments(kind, operands, ep, env); end
  def show_block_signature(blks); end
  def show_method_signature(ctx); end
  def show_proc_signature(blks); end
  def step(ep); end
  def traverse_subclasses(klass, &blk); end
  def type_profile(cancel_token = nil); end
  def type_to_keywords(ty, ep); end
  def update_container_elem_types(env, ep, id, base_type); end
  def warn(ep, msg); end
end
class TypeProf::Scratch::ClassDef
  def absolute_path; end
  def add_class_open(name, open_ep); end
  def add_constant(name, ty, def_ep); end
  def add_method(mid, singleton, mdef); end
  def adjust_substitution(singleton, mid, mthd, subst, direct, &blk); end
  def adjust_substitution_for_module(mods, mid, mthd, subst, &blk); end
  def check_typed(mid, singleton, klass); end
  def check_typed_attr(mid, singleton); end
  def check_typed_method(mid, singleton); end
  def consts; end
  def cvars; end
  def get_constant(name); end
  def initialize(kind, name, absolute_path, superclass); end
  def ivars; end
  def kind; end
  def klass_obj; end
  def klass_obj=(arg0); end
  def methods; end
  def mix_module(kind, mod, type_args, singleton, absolute_path); end
  def modules; end
  def name; end
  def name=(arg0); end
  def search_method(singleton, mid, visited, &blk); end
  def set_method(mid, singleton, mdef); end
  def subclasses; end
  def superclass; end
end
class TypeProf::Scratch::VarTable
  def add_read!(site, ep, &ctn); end
  def add_write!(site, ty, ep, scratch); end
  def dump; end
  def initialize; end
end
class TypeProf::Scratch::VarTable::Entry < Struct
  def absolute_paths; end
  def absolute_paths=(_); end
  def rbs_declared; end
  def rbs_declared=(_); end
  def read_continuations; end
  def read_continuations=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
  def write_eps; end
  def write_eps=(_); end
end
class TypeProf::RBSReader
  def initialize; end
  def load_builtin; end
  def load_library(lib); end
  def load_paths(paths); end
  def load_rbs_string(name, content); end
  def self.get_builtin_env; end
  def self.load_rbs(env, new_decls); end
end
class TypeProf::RBSReader::RBSCollectionDefined < StandardError
end
class TypeProf::RBS2JSON
  def attr_method_def(kind, name, ty, visibility); end
  def attr_rbs_source(member); end
  def conv_block(rbs_block); end
  def conv_classes; end
  def conv_constants; end
  def conv_func(type_params, func, block); end
  def conv_globals; end
  def conv_method_def(rbs_method_types, visibility); end
  def conv_type(ty); end
  def conv_type_name(name); end
  def dump_json; end
  def each_class_decl; end
  def each_reference(decl, &blk); end
  def get_super_class(name, decls); end
  def initialize(all_env, cur_env); end
end
class TypeProf::Import
  def conv_attr_defs(mdef, rbs_source); end
  def conv_block(blk); end
  def conv_func(sig_ret); end
  def conv_method_def(method_name, mdef, rbs_source); end
  def conv_type(ty); end
  def import(explicit = nil); end
  def initialize(scratch, json); end
  def path_to_klass(path); end
  def self.import_builtin(scratch); end
  def self.import_library(scratch, feature); end
  def self.import_rbs_code(scratch, rbs_name, rbs_code); end
  def self.import_rbs_files(scratch, rbs_paths); end
end
module TypeProf::Reporters
  def filter_backtrace(trace); end
  def generate_analysis_trace(state, visited, backward_edge); end
  def self.filter_backtrace(trace); end
  def self.generate_analysis_trace(state, visited, backward_edge); end
  def self.show_error(errors, backward_edge, output); end
  def self.show_gvars(scratch, gvars, output); end
  def self.show_message(terminated, output); end
  def self.show_reveal_types(scratch, reveal_types, output); end
  def show_error(errors, backward_edge, output); end
  def show_gvars(scratch, gvars, output); end
  def show_message(terminated, output); end
  def show_reveal_types(scratch, reveal_types, output); end
end
class TypeProf::RubySignatureExporter
  def build_class_hierarchy(namespace, hierarchy); end
  def conv_class(namespace, class_def, inner_classes); end
  def conv_class_lsp(namespace, class_def); end
  def initialize(scratch, class_defs, iseq_method_to_ctxs); end
  def show(stat_eps, output); end
  def show_class_data(depth, class_data); end
  def show_class_hierarchy(depth, hierarchy); end
  def show_const(namespace, path); end
  def show_lsp; end
end
class TypeProf::RubySignatureExporter::ClassData < Struct
  def consts; end
  def consts=(_); end
  def cvars; end
  def cvars=(_); end
  def inner_classes; end
  def inner_classes=(_); end
  def ivars; end
  def ivars=(_); end
  def kind; end
  def kind=(_); end
  def methods; end
  def methods=(_); end
  def modules; end
  def modules=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def source_locations; end
  def source_locations=(_); end
  def superclass; end
  def superclass=(_); end
  def visibilities; end
  def visibilities=(_); end
end
module TypeProf::Builtin
  def array_aref(recv, mid, aargs, ep, env, scratch, &ctn); end
  def array_aset(recv, mid, aargs, ep, env, scratch, &ctn); end
  def array_pop(recv, mid, aargs, ep, env, scratch, &ctn); end
  def get_sym(target, ty, ep, scratch); end
  def hash_aref(recv, mid, aargs, ep, env, scratch, &ctn); end
  def hash_aset(recv, mid, aargs, ep, env, scratch, &ctn); end
  def kernel_Array(recv, mid, aargs, ep, env, scratch, &ctn); end
  def kernel_autoload(recv, mid, aargs, ep, env, scratch, &ctn); end
  def kernel_p(recv, mid, aargs, ep, env, scratch, &ctn); end
  def kernel_require(recv, mid, aargs, ep, env, scratch, &ctn); end
  def kernel_require_relative(recv, mid, aargs, ep, env, scratch, &ctn); end
  def lambda(recv, mid, aargs, ep, env, scratch, &ctn); end
  def module_attr_accessor(recv, mid, aargs, ep, env, scratch, &ctn); end
  def module_attr_reader(recv, mid, aargs, ep, env, scratch, &ctn); end
  def module_attr_writer(recv, mid, aargs, ep, env, scratch, &ctn); end
  def module_autoload(recv, mid, aargs, ep, env, scratch, &ctn); end
  def module_define_method(recv, mid, aargs, ep, env, scratch, &ctn); end
  def module_eqq(recv, mid, aargs, ep, env, scratch, &ctn); end
  def module_extend(recv, mid, aargs, ep, env, scratch, &ctn); end
  def module_include(recv, mid, aargs, ep, env, scratch, &ctn); end
  def module_module_function(recv, mid, aargs, ep, env, scratch, &ctn); end
  def module_prepend(recv, mid, aargs, ep, env, scratch, &ctn); end
  def module_private(recv, mid, aargs, ep, env, scratch, &ctn); end
  def module_public(recv, mid, aargs, ep, env, scratch, &ctn); end
  def object_block_given?(recv, mid, aargs, ep, env, scratch, &ctn); end
  def object_class(recv, mid, aargs, ep, env, scratch, &ctn); end
  def object_enum_for(recv, mid, aargs, ep, env, scratch, &ctn); end
  def object_instance_eval(recv, mid, aargs, ep, env, scratch, &ctn); end
  def object_is_a?(recv, mid, aargs, ep, env, scratch, &ctn); end
  def object_module_eval(recv, mid, aargs, ep, env, scratch, &ctn); end
  def object_privitive_method(recv, mid, aargs, ep, env, scratch, &ctn); end
  def object_respond_to?(recv, mid, aargs, ep, env, scratch, &ctn); end
  def object_s_new(recv, mid, aargs, ep, env, scratch, &ctn); end
  def object_send(recv, mid, aargs, ep, env, scratch, &ctn); end
  def proc_call(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.array_aref(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.array_aset(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.array_pop(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.file_load(path, ep, env, scratch, &ctn); end
  def self.file_require(feature, scratch); end
  def self.get_sym(target, ty, ep, scratch); end
  def self.hash_aref(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.hash_aset(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.kernel_Array(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.kernel_autoload(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.kernel_p(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.kernel_require(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.kernel_require_relative(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.lambda(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.module_attr_accessor(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.module_attr_reader(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.module_attr_writer(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.module_autoload(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.module_define_method(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.module_eqq(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.module_extend(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.module_include(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.module_module_function(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.module_prepend(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.module_private(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.module_public(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.object_block_given?(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.object_class(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.object_enum_for(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.object_instance_eval(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.object_is_a?(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.object_module_eval(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.object_privitive_method(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.object_respond_to?(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.object_s_new(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.object_send(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.proc_call(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.setup_initial_global_env(scratch); end
  def self.struct_initialize(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.struct_s_new(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.vmcore_hash_merge_kwd(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.vmcore_raise(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.vmcore_set_method_alias(recv, mid, aargs, ep, env, scratch, &ctn); end
  def self.vmcore_undef_method(recv, mid, aargs, ep, env, scratch, &ctn); end
  def struct_initialize(recv, mid, aargs, ep, env, scratch, &ctn); end
  def struct_s_new(recv, mid, aargs, ep, env, scratch, &ctn); end
  def vmcore_hash_merge_kwd(recv, mid, aargs, ep, env, scratch, &ctn); end
  def vmcore_raise(recv, mid, aargs, ep, env, scratch, &ctn); end
  def vmcore_set_method_alias(recv, mid, aargs, ep, env, scratch, &ctn); end
  def vmcore_undef_method(recv, mid, aargs, ep, env, scratch, &ctn); end
end
module TypeProf::CLI
  def parse(argv); end
  def self.parse(argv); end
end
class TypeProf::CodeLocation
  def <=>(other); end
  def advance_cursor(offset, source_text); end
  def column; end
  def initialize(lineno, column); end
  def inspect; end
  def lineno; end
  def self.from_lsp(lsp_loc); end
  def to_lsp; end
  include Comparable
end
class TypeProf::CodeRange
  def contain?(other); end
  def contain_loc?(loc); end
  def first; end
  def initialize(first, last); end
  def inspect; end
  def last; end
  def overlap?(other); end
  def self.from_lsp(lsp_range); end
  def self.from_rbs(rbs_loc); end
  def to_lsp; end
end
class TypeProf::CodeRangeTable
  def [](loc); end
  def []=(range, value); end
  def initialize(list = nil); end
end
class TypeProf::CodeRangeTable::Entry < Struct
  def children; end
  def children=(_); end
  def inspect; end
  def range; end
  def range=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def value; end
  def value=(_); end
end
module TypeProf::LSP
end
class TypeProf::LSP::CompletionSession < Struct
  def results; end
  def results=(_); end
  def reusable?(other_row, other_start_col_offset); end
  def row; end
  def row=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def start_col_offset; end
  def start_col_offset=(_); end
end
class TypeProf::LSP::Text
  def analyze(uri, text, cancel_token: nil, signature_help_loc: nil); end
  def apply_changes(changes, version); end
  def caller_table; end
  def code_complete(loc, trigger_kind); end
  def definition_table; end
  def definition_table=(arg0); end
  def initialize(server, uri, text, version); end
  def lines; end
  def locate_arg_index_in_signature_help(node, loc, sig_help); end
  def new_code_completion_session(row, start_offset, end_offset); end
  def on_text_changed; end
  def on_text_changed_analysis(res, definition_table, caller_table); end
  def push_analysis_queue(&work); end
  def signature_help(loc, trigger_kind); end
  def sigs; end
  def text; end
  def version; end
end
class TypeProf::LSP::Text::AnalysisToken < TypeProf::Utils::CancelToken
  def cancel; end
  def cancelled?; end
  def initialize; end
end
class TypeProf::LSP::Message
  def initialize(server, json); end
  def respond(result); end
  def respond_error(error); end
  def run; end
  def self.build_table; end
  def self.find(method); end
  def self.inherited(klass); end
end
module TypeProf::LSP::ErrorCodes
end
class TypeProf::LSP::Message::Initialize < TypeProf::LSP::Message
  def run; end
end
class TypeProf::LSP::Message::Initialized < TypeProf::LSP::Message
  def run; end
end
class TypeProf::LSP::Message::Shutdown < TypeProf::LSP::Message
  def run; end
end
class TypeProf::LSP::Message::Exit < TypeProf::LSP::Message
  def run; end
end
module TypeProf::LSP::Message::Workspace
end
class TypeProf::LSP::Message::Workspace::DidChangeWatchedFiles < TypeProf::LSP::Message
  def run; end
end
class TypeProf::LSP::Message::Workspace::ExecuteCommand < TypeProf::LSP::Message
  def run; end
end
module TypeProf::LSP::Message::TextDocument
end
class TypeProf::LSP::Message::TextDocument::DidOpen < TypeProf::LSP::Message
  def run; end
end
class TypeProf::LSP::Message::TextDocument::DidChange < TypeProf::LSP::Message
  def cancel; end
  def run; end
end
class TypeProf::LSP::Message::TextDocument::DidClose < TypeProf::LSP::Message
  def run; end
end
class TypeProf::LSP::Message::TextDocument::Definition < TypeProf::LSP::Message
  def run; end
end
class TypeProf::LSP::Message::TextDocument::TypeDefinition < TypeProf::LSP::Message
  def run; end
end
class TypeProf::LSP::Message::TextDocument::References < TypeProf::LSP::Message
  def run; end
end
module TypeProf::LSP::CompletionTriggerKind
end
class TypeProf::LSP::Message::TextDocument::Completion < TypeProf::LSP::Message
  def run; end
end
class TypeProf::LSP::Message::TextDocument::SignatureHelp < TypeProf::LSP::Message
  def run; end
end
class TypeProf::LSP::Message::TextDocument::CodeLens < TypeProf::LSP::Message
  def run; end
end
class TypeProf::LSP::Message::CancelRequest < TypeProf::LSP::Message
  def run; end
end
class TypeProf::LSP::Reader
  def initialize(io); end
  def read; end
end
class TypeProf::LSP::Reader::ProtocolError < StandardError
end
class TypeProf::LSP::Writer
  def initialize(io); end
  def write(**json); end
end
module TypeProf::LSP::Writer::ErrorCodes
end
module TypeProf::LSP::Helpers
  def pos(line, character); end
  def range(s, e); end
end
module TypeProf::LSP::MessageType
end
class TypeProf::LSP::Server
  def exclusive_write(**json); end
  def initialize(config, reader, writer); end
  def open_texts; end
  def root_uri; end
  def root_uri=(arg0); end
  def run; end
  def running_requests_from_client; end
  def send_notification(method, params = nil); end
  def send_request(method, **params, &blk); end
  def send_response(**msg); end
  def signature_enabled; end
  def signature_enabled=(arg0); end
  def sigs; end
  def typeprof_config; end
  include TypeProf::LSP::Helpers
end
class TypeProf::LSP::Server::Exit < StandardError
end
class SampleSorbet
  def animal(*args, &blk); end
  def height(*args, &blk); end
  def hello(*args, &blk); end
  def initialize(*args, &blk); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
